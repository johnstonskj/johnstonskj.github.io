---
title: Code4Fun
layout: catpage
category: code
---

At work the major platform is the JVM, I say that rather than Java because
there is most definitely a growing trend away from Java to achieve better
individual and team productivity. Scala has played a role in this but it
appears that the current leading choice is now [Kotlin](https://kotlinlang.org/),
which I have to say I do like a lot. Additionally there is interest in 
non-JVM languages with Go and [Rust](https://www.rust-lang.org/) being the 
two front runners. For small tools I have tended to rely on Python since 
the mid 90's, although I have become worryingly comfortable writing 
shell (zsh) scripts.

I do like to use [Jupyter](https://jupyter.org/) for experiments, and for 
documenting ideas where the/an algorithm is a part of the process. I have 
in the past also used Mathematica (now the [Wolfram Language](https://www.wolfram.com/language/)) 
for similar tasks, and still love the "batteries included" capabilities 
of the language. 

At home, [Racket](https://racket-lang.org/) is my favorite small tool 
language, taking the place of Python for a lot of tasks. I have also started
to use Rust more as well. One personal project that has been very rewarding
is the development of a set of Racket packages implementing some core
Machine Learning (ML) algorithms. These packages are not intended to be 
production ready, I wanted to learn more about how ML processes worked
and decided the best way was from the ground up. The result is a set of 
simple, pedantic implementations that are written to be readable rather
than to scale.

## Development Environment

Most of my development is done old school, command line style, on macOS 
and Linux. I use Amazon Linux at work, Ubuntu at home and have more than
one MacBook Pro. I have weened myself of Eclipse, and while I have gone back to
Emacs for a lot, I do use [IDEA](https://www.jetbrains.com/idea/) for Kotlin,
Python, and Rust development. 

I keep the development environment across these machines approximately in 
sync using a [dotfiles](https://github.com/johnstonskj/dotfiles) repository 
in GitHub.

The sweet ML development machine under the desk at home is based on an 
[HP Omen](https://store.hp.com/us/en/pdp/omen-desktop-pc-880-160se-2tb61av-1)
desktop with 64Gb memory, 8Tb disk, 512Gb SSD, an NVIDIA GTX 1080i and an
NVIDIA Titan V, running Ubuntu for GPU training and inferencing. I use the same 
large monitor at work, and at home, a Dell
[UltraSharp U3415W 34-Inch Curved](https://www.dell.com/en-us/shop/accessories/apd/210-adtr).

## Interesting Links

* [Reading List](reading.md)
* [Quotes for Software Geeks](quotes.md)
* [GitHub Repositories](https://github.com/johnstonskj?tab=repositories)

## Programming Languages I Have Known

Yes, I collect these things; I am fascinated by the different approaches that 
languages take, the evolution among language families, and the specialization
and generalization they support. I also periodically scan eBay and others for
manuals and books for the more obscure or fossilized languages. Unfortunately
some of these only exist as online, usually PDF, scanned manuals.

### Because someone paid me to

* Ada 83/95
* BASIC Family
  * MS/Sanyo Basic
  * Visual Basic
* COBOL
* C Family
  * C
  * C++; Glockenspiel, Zortech, MSVCC, GCC, CLANG
  * C#
  * Objective-C
* Erlang
* FoxPro
* JavaScript
* JVM Focused
  * Java
  * Kotlin
  * Scala
* _Lispy_ Languages
  * Clojure
* Mathematica/Wolfram
* Modula-2
* Perl
* Progress 4GL
* Python (from 0.5, and built first non-Unix port)
* Query/Constraint Languages
  * OCL
  * SPARQL
  * SQL; DB2, MS T-SQL, Oracle PSQL, Postgres

### Mostly for fun, or education

* Assembler
  * 6502
  * 8088
  * 80x86
* BASIC Family 
  * BBC Basic
  * Commodore Basic+
* Eiffel
* Esterel
* Forth
* F#
* _Lispy_ Languages
  * Racket
  * Scheme
* ML Family
  * Haskell
  * Miranda
  * OCaml
* Occam
* Pascal Family
  * Modula-3
  * Oberon
  * Turbo Pascal
  * VAX Pascal
* Prolog
* SNOBOL
* Smalltalk, including Squeak
