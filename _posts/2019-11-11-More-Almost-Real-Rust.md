---
title: More, Almost Real, Rust
layout: post
category: code
tags: [rust, work]
---

The opportunity came up at work to build a Proof of Concept for a fairly critical service, and as it was our explicit intent that the team building the *real* service would not use this as the basis for their work we (myself and two other principal engineers, Steve and Jenn) chose to build it in Rust. Our motivations differed a little, personally I wanted to explore the Rust claim of *no-cost abstractions* in building more complex code than I have needed to so far. I also wanted to get a feel for writing server side Rust as most of the code I've written has been command line tooling or libraries. For Steve it was really exploring Rust in general and as a viable alternative for some teams that have started to look at Go. He had pretty deep experience in Go so there was some compare and contrast at work.

I think the month or so we worked on it (but not full time for any of us) was a good experience, it certainly met our work goal of providing enough implementation to prove our ideas and flesh out the API design and behavior. I also think we three agree that the experience was overall very positive both in tooling, documentation, crate availability, and community support. Going in we had read that the tooling had a poor reputation, but clearly that advice is out of date; the compiler was rarely anything but precise and I found the messages of the form "you can't do this *here*, because you did that *there*" really valuable. The link to more details online for so many compiler messages was also helpful, though not equally for all errors. The combination of `rustup` and `cargo` provide a great combination, and while these kinds of tools may be expected these days, like Python's Anaconda, these are simple, lightweight and really help the getting started experience. 

The fact that there is one style for code, a really pedantic linter, and a very strong opinion around idiomatic Rust makes it way easier to focus on writing what's in your head and letting `rustfmt` and `clippy` deal with the details. I think for most people a combination of the strong static type system and borrow checker can result in a very frustrating initial experience, and not uncommon to hear comments like "that compiler is an asshole!" Once you get past the anthropomorphism you'll find that the compiler is actually trying to be your friend, but that really good friend that knows when your about to do something really stupid and takes away your keys, or sometimes your chainsaw. Having your editor (I use IntelliJ IDEA, Vim was used on this project too) automatically run  `rustfmt` and `clippy` on every change means you can just type any nonsense, or hack at existing change and watch it get laid out nicely for you! Oh and when you use a really nice gaming desktop for compilation that support is near instant!

One of my co-conspirators on this effort gave a presentation to a really great group of senior engineers and got to the line "thread safe, memory safe, and no data races" a number of reactions of the form *bullshit!* were actually turned into curiosity and respect once they understood the borrow checker (oh and Kudos for Steve for being able to explain that faster than any method I've seen to date). I know at least none team that is going to revisit their recent decision to use Go with AWS Lambda as Rust is supported too, and another team interested in the performance benefits. 

So, now I am looking for the next PoC, it feels really good to be coding again :)